{
  "hash": "b064c021d969171950ab543bfe46f85e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nimage: figure.jpg\npage-layout: article\ntitle-block-banner: coleta.png\ndate: \"2023-12-20\"\ntitle: \"Pensando sobre o processo de Amostragem\"\nauthor: \"Gabriel Palucci Rosa\"\ntoc: true\ntoc-title: \"Table of Content\"\ncategories:\n  - Solo\n  - Amostragem\n  - ggplot\n---\n\n\n# Introdução\n\nUns dos vários desafios na realizar uma pesquisa ciêntifica é planejar e executar, de forma eficiente, o processo de deliamento amostral.Um boa amamostragem permitira, realizar melhor discussão sobre dados coletados. Esse post busco apresentar um pouco sobre o processo de realizar amostragem e os efeitos de realizar poucas repetições ou diferentes tamanho da coleta da amostra.\n\nAntes de utilizar exemplos sobre solo, utilizaremos uma base de dados de bolinhhas vermelhas e brancas. Importante lembrar o processo de amostragem necessita uma repetição para obter uma frequencia de % da ocorrência do do valor.\n\nAssim, existe dois efeitos improtantes que serão descutidos nesse tópico\n\n-   Efeito na variação de dados nas amostragem\n-   EFeito do tamanho da amostragem na variação da amostra\n\n# Estudo de Caso\n\n## Utilizando Bolinhas para enteder processo de amostragem\n\n#/Pacotes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(moderndive)\n```\n:::\n\n\n#/Dados\n\nPara isso vamos utilizar a base de dados *bowl* para demostrar o processo de amostragem\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbowl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,400 × 2\n   ball_ID color\n     <int> <chr>\n 1       1 white\n 2       2 white\n 3       3 white\n 4       4 red  \n 5       5 white\n 6       6 white\n 7       7 red  \n 8       8 white\n 9       9 red  \n10      10 white\n# ℹ 2,390 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvirtual_shovel <- bowl %>% \n     rep_sample_n(size = 50)\n```\n:::\n\n\nNesse caso, utilizamos o comando *rep_sample_n* para selecior 50 amostras de forma randômica do nossa base de dados.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvirtual_shovel %>%\n  mutate(is_red = color == \"red\") %>% \n  summarize(num_red = sum(is_red)) %>% \n  mutate(prop_red = num_red / 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  replicate num_red prop_red\n      <int>   <int>    <dbl>\n1         1      15      0.3\n```\n\n\n:::\n:::\n\n\nNesse exemplo, pegamos nossa base de dados *virtual_shovel* criamos uma variaável Logical utilizando argumento cor é igual a vermelho, posteriormente realizamos summarize da soma dessa nova variável e finalizamos obtendo a proporção de vermelho na amostragem total que é 50.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbowl %>% \n     rep_sample_n(size = 50, reps = 33) %>% \n     group_by(replicate) %>% \n     summarize(red = sum(color == \"red\")) %>% \n     mutate(prop_red = red / 50)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 33 × 3\n   replicate   red prop_red\n       <int> <int>    <dbl>\n 1         1    16     0.32\n 2         2    16     0.32\n 3         3    14     0.28\n 4         4    16     0.32\n 5         5    17     0.34\n 6         6    21     0.42\n 7         7    14     0.28\n 8         8    16     0.32\n 9         9    14     0.28\n10        10    17     0.34\n# ℹ 23 more rows\n```\n\n\n:::\n:::\n\n\nComo podemos observar, realizamos uma amostragem de 50 bolinhas 33 vezes e obtemos a proporção de bolinhar vermelhas em cada amostragem.\n\n*O valor do tamanho da amostragem influência na proporção das bolinhas vermelhas?*\n\n*O valor do tamanho da amostragem influência desvio padrão das bolinhas vermelhas?*\n\nDesde modo iremos realizar amostragem 25,50, 100 bolinhas em 100 repetições e observar a resposta da porcentagem e sua frequencia\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvirtual_samples_25 <- bowl %>% \n  rep_sample_n(size = 25, reps = 100) %>% \n  group_by(replicate) %>% \n  summarize(red = sum(color == \"red\")) %>% \n  mutate(prop_red = red / 25)\n\n  \n# 1.c) Plot distribution via a histogram\nggplot(virtual_samples_25, aes(x = prop_red)) +\n  geom_histogram(binwidth = 0.05, boundary = 0.4, color = \"white\") +\n  labs(x = \"Proportion of 25 balls that were red\", title = \"25\") \n```\n\n::: {.cell-output-display}\n![](Amostragem_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Segment 2: sample size = 50 ------------------------------\n# 2.a) Virtually use shovel 1000 times\nvirtual_samples_50 <- bowl %>% \n  rep_sample_n(size = 50, reps = 1000)\n\n# 2.b) Compute resulting 1000 replicates of proportion red\nvirtual_prop_red_50 <- virtual_samples_50 %>% \n  group_by(replicate) %>% \n  summarize(red = sum(color == \"red\")) %>% \n  mutate(prop_red = red / 50)\n\n# 2.c) Plot distribution via a histogram\nggplot(virtual_prop_red_50, aes(x = prop_red)) +\n  geom_histogram(binwidth = 0.05, boundary = 0.4, color = \"white\") +\n  labs(x = \"Proportion of 50 balls that were red\", title = \"50\")  \n```\n\n::: {.cell-output-display}\n![](Amostragem_files/figure-html/unnamed-chunk-6-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Segment 3: sample size = 100 ------------------------------\n# 3.a) Virtually using shovel with 100 slots 1000 times\nvirtual_samples_100 <- bowl %>% \n  rep_sample_n(size = 100, reps = 1000)\n\n# 3.b) Compute resulting 1000 replicates of proportion red\nvirtual_prop_red_100 <- virtual_samples_100 %>% \n  group_by(replicate) %>% \n  summarize(red = sum(color == \"red\")) %>% \n  mutate(prop_red = red / 100)\n\n# 3.c) Plot distribution via a histogram\nggplot(virtual_prop_red_100, aes(x = prop_red)) +\n  geom_histogram(binwidth = 0.05, boundary = 0.4, color = \"white\") +\n  labs(x = \"Proportion of 100 balls that were red\", title = \"100\") \n```\n\n::: {.cell-output-display}\n![](Amostragem_files/figure-html/unnamed-chunk-6-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# n = 25\n\n# virtual_prop_red_25 %>% \n#   summarize(sd = sd(prop_red))\n\n# n = 50\nvirtual_prop_red_50 %>% \n  summarize(sd = sd(prop_red))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      sd\n   <dbl>\n1 0.0688\n```\n\n\n:::\n\n```{.r .cell-code}\n# n = 100\nvirtual_prop_red_100 %>% \n  summarize(sd = sd(prop_red))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n      sd\n   <dbl>\n1 0.0476\n```\n\n\n:::\n:::\n\n\nÀ medida que o tamanho da amostra aumenta, o desvio padrão da proporção de bolas vermelhas diminui. Este tipo de desvio padrão tem outro nome especial: erro padrão. Os erros padrão quantificam o efeito da variação de amostragem induzida em nossas estimativas. Em outras palavras, eles quantificam quanto podemos esperar que diferentes proporções de bolas vermelhas em uma pá variem de uma amostra para outra, e assim por diante.\n\nComo regra geral, à medida que o tamanho da amostra aumenta, o erro padrão diminui.\n",
    "supporting": [
      "Amostragem_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}